extern crate ncurses;
extern crate rand;
use ncurses::*;
use rand::seq::SliceRandom;
use std::collections::HashSet;

const MAZE_WIDTH: i32 = 31;
const MAZE_HEIGHT: i32 = 15;

pub struct Maze {
    pub grid: HashSet<(i32, i32)>,
}

/// Generates a maze using the recursive backtracking algorithm.
///
/// The maze is represented as a `HashSet` of `(i32, i32)` coordinates representing the
/// cells in the maze. The maze is generated by starting in the top-left corner and then
/// recursively carving passages in a random order.
///
/// The recursive backtracking algorithm works by recursively carving passages in the
/// maze until all cells have been visited. The algorithm starts by choosing a random
/// direction to move in, and then checks if the adjacent cell is within the bounds of
/// the maze and if it is not already a part of the maze. If the adjacent cell is valid,
/// then the algorithm carves a passage in the adjacent cell and then recursively calls
/// itself in the adjacent cell. If the adjacent cell is not valid, then the algorithm
/// moves on to the next direction.
pub fn generate_maze(rng: &mut impl rand::Rng) -> Maze {
    let mut grid = HashSet::new();

    /// Recursively carves a passage in the maze.
    ///
    /// # Arguments
    /// * `grid`: The grid to carve the passage in. This is a `HashSet` of `(i32, i32)`
    ///   coordinates representing the cells in the maze.
    /// * `x`: The x coordinate of the current cell.
    /// * `y`: The y coordinate of the current cell.
    /// * `rng`: The random number generator used to shuffle the directions.
    ///
    /// This function first checks if the current cell is within the bounds of the maze,
    /// and if it is not already a part of the maze. If the current cell is valid, then
    /// the algorithm carves a passage in the current cell and then recursively calls
    /// itself in the adjacent cell. If the current cell is not valid, then the algorithm
    /// returns without doing anything.
    fn carve_passage(grid: &mut HashSet<(i32, i32)>, x: i32, y: i32, rng: &mut impl rand::Rng) {
        // Insert the current cell into the grid. This is necessary because we don't want
        // to carve a passage in a cell that is already part of the maze.
        grid.insert((x, y));

        // Define the four possible directions to move in. These are the four cardinal
        // directions: up, down, left, and right.
        let directions = [(0, 2), (2, 0), (0, -2), (-2, 0)];

        // Shuffle the directions randomly. This is necessary because we want to create a
        // random maze. If we didn't shuffle the directions, we would always carve a
        // passage in the same direction (up, then right, then down, then left).
        let mut directions = directions.to_vec();
        directions.shuffle(rng);

        // Iterate over the shuffled directions.
        for (dx, dy) in directions {
            // Calculate the coordinates of the adjacent cell. This is necessary because we
            // need to know where to carve the passage.
            let nx = x + dx;
            let ny = y + dy;

            // Check if the adjacent cell is within the bounds of the maze and if it is not
            // already a part of the maze. This is necessary because we don't want to carve
            // a passage in a cell that is outside the bounds of the maze or in a cell that
            // is already part of the maze.
            if nx > 0 && nx < MAZE_WIDTH - 1 && ny > 0 && ny < MAZE_HEIGHT - 1 && !grid.contains(&(nx, ny)) {
                // Check if the cell between the current cell and the adjacent cell is also
                // within the bounds of the maze. This is necessary because we are using a
                // recursive backtracking algorithm. If the cell between the current cell and
                // the adjacent cell is not within the bounds of the maze, then we can't
                // carve a passage in the adjacent cell.
                if (y + dy / 2) >= 0 && (y + dy / 2) < MAZE_HEIGHT && (x + dx / 2) >= 0 && (x + dx / 2) < MAZE_WIDTH {
                    // Insert the cell between the current cell and the adjacent cell into the
                    // grid. This is necessary because we need to know which cells are part of
                    // the maze.
                    grid.insert((x + dx / 2, y + dy / 2));
                    // Recursively carve a passage in the adjacent cell. This is necessary
                    // because we need to carve a passage in all cells in the maze.
                    carve_passage(grid, nx, ny, rng);
                }
            }
        }
    }

    // Start carving passages in the maze. This is necessary because we need to carve a
    // passage in all cells in the maze.
    carve_passage(&mut grid, 1, 1, rng);
    // Return the maze.
    Maze { grid }
}

/// Draws the maze to the screen.
///
/// # Arguments
///
/// * `maze`: A reference to the maze structure (`&Maze`) that contains the layout of the maze.
///
/// This function is responsible for drawing the maze to the screen. It does this by
/// iterating over each cell in the maze and determining whether the cell is a wall
/// or not. If the cell is not a wall, it will draw a space character in the cell. If
/// the cell is a wall, it will draw a '#' character in the cell.
///
/// The function works by first iterating over each row of the maze. For each row, it
/// will then iterate over each column in the current row. This is necessary because
/// we need to draw each cell in the maze.
///
/// For each cell, the function will then determine whether the cell is a wall or not.
/// It does this by checking if the cell is in the maze's grid. If the cell is in the
/// grid, it is not a wall. If the cell is not in the grid, it is a wall.
///
/// Once the function has determined whether the cell is a wall or not, it will then
/// draw the character in the cell at (x, y) on the screen. If the cell is not a wall,
/// it will draw a space character. If the cell is a wall, it will draw a '#' character.
///
/// This function is necessary because we need to visually represent the maze on the
/// screen. We need to do this so that the player can see the maze and so that they can
/// navigate through it.
pub fn draw_maze(maze: &Maze) -> () {
    if maze.grid.is_empty() {
        panic!("The maze is empty and cannot be drawn.");
    }
    let mut row: String = String::new();
    // Iterate over each row of the maze.
    for y in 0..MAZE_HEIGHT {
        // Clear the row string.
        row.clear();
        // Iterate over each column in the current row.
        for x in 0..MAZE_WIDTH {
            // Determine whether the cell at (x, y) is a wall or not.
            let ch: char = if maze.grid.contains(&(x, y)) { ' ' } else { '#' };
            // Append the character to the row string.
            row.push(ch);
        }
        // Draw the row string on the screen.
        mvaddstr(y as i32, 0, row.as_str());
    }
}
